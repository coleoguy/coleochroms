x.init = runif(7, min = 0, max = 1),
prior = prior, upper = 40, w = new.W,
print.every=10, nsteps = iter.full)
# this version creates a one way model where wings can not be regained
con.lk.mk<-constrainMkn(data=chrom.mat,
lik=lk.mk,
hyper=T,
polyploidy=F,
verbose=F,
oneway=T,
constrain=list(drop.demi=T))
help("constrainMkn")
# this version creates a one way model where wings can not be regained
con.lk.mk<-constrainMkn(data=chrom.mat,
lik=lk.mk,
hyper=T,
polyploidy=F,
verbose=F,
constrain=list(drop.demi=T))
# we use a broad prior
prior <- make.prior.exponential(1)
print(paste("Working on dataset", i))
results[[i]] <- diversitree::mcmc(con.lk.mk,
x.init = runif(7, min = 0, max = 1),
prior = prior, upper = 40, w = new.W,
print.every=10, nsteps = iter.full)
results[[i]] <- diversitree::mcmc(con.lk.mk,
x.init = runif(8, min = 0, max = 1),
prior = prior, upper = 40, w = new.W,
print.every=10, nsteps = iter.full)
results[[i]] <- diversitree::mcmc(con.lk.mk,
x.init = runif(8, min = 0, max = 1),
prior = prior, upper = 40, w = 1,
print.every=10, nsteps = iter.full)
foo <- results[1[]]
foo <- results[[1]]
View(foo)
colMeans(foo[250:500])
colMeans(foo[250:500,])
matrix(c(0,1,0,0))
matrix(c(0,1,2,2))
matrix(c(0,1,0,0),2,2)
matrix(c(0,0,1,0),2,2)
# this version creates a one way model where wings can not be regained
con.lk.mk<-constrainMkn(data=chrom.mat,
lik=lk.mk,
hyper=T,
polyploidy=F,
verbose=F,
constrain=list(meta = matrix(c(0,0,1,0),2,2), drop.demi=T))
constrainMkn()
constrainMkn
library(chromePlus)
library(coda)
library(diversitree)
trees <- read.nexus("../data/trees.nexus")
chroms <- read.csv("../data/hap.auto.csv", as.is=T)
# state 1 is winged
#lets prune trees
library(geiger)
row.names(chroms) <- chroms$name
# here we scale our trees to unit length and store there orginal depth
trees.p <- list()
scaler <- c()
for(i in 1:100){
print(i)
trees.p[[i]] <- treedata(trees[[i]], chroms)[[1]]
scaler[i] <- max(branching.times(trees.p[[i]]))
trees.p[[i]]$edge.length <- trees.p[[i]]$edge.length/scaler[i]
}
# here we match up our tip data and our
trees <- trees.p
class(trees) <- "multiPhylo"
x <- row.names(treedata(trees[[1]], chroms)[[2]])
chroms <- chroms[chroms$name%in%x,]
rm(trees.p,i,x)
range(chroms$chrom.num)
# here we go conservative and set wingstate to wingless
# if any records suggest this is the case
wingstate <- c()
for(j in 1:length(chroms$wings.present)){
p <- chroms$wings.present[j]
if(chroms$wings.present[j] < 1) wingstate[j] <- 0
if(chroms$wings.present[j] == 1) wingstate[j] <- 1
}
p <- chroms$wings.present[j]
chroms$wings.present
j <- 74
p <- chroms$wings.present[j]
sample(c(0,1), prob=c(1-p, p), size = 1)
sample(c(0,1), prob=c(1-p, p), size = 1)
sample(c(0,1), prob=c(1-p, p), size = 1)
sample(c(0,1), prob=c(1-p, p), size = 1)
sample(c(0,1), prob=c(1-p, p), size = 1)
sample(c(0,1), prob=c(1-p, p), size = 1)
j <- 133
p <- chroms$wings.present[j]
sample(c(0,1), prob=c(1-p, p), size = 1)
sample(c(0,1), prob=c(1-p, p), size = 1)
sample(c(0,1), prob=c(1-p, p), size = 1)
sample(c(0,1), prob=c(1-p, p), size = 1)
sample(c(0,1), prob=c(1-p, p), size = 1)
sample(c(0,1), prob=c(1-p, p), size = 1)
sample(c(0,1), prob=c(1-p, p), size = 1)
sample(c(0,1), prob=c(1-p, p), size = 1)
sample(c(0,1), prob=c(1-p, p), size = 1)
sample(c(0,1), prob=c(1-p, p), size = 1)
sample(c(0,1), prob=c(1-p, p), size = 1)
sample(c(0,1), prob=c(1-p, p), size = 1)
library(devtools)
install_github('coleoguy/chromePlus')
library(chromePlus)
library(coda)
library(diversitree)
trees <- read.nexus("../data/trees.nexus")
chroms <- read.csv("../data/hap.auto.csv", as.is=T)
# state 1 is winged
#lets prune trees
library(geiger)
row.names(chroms) <- chroms$name
# here we scale our trees to unit length and store there orginal depth
trees.p <- list()
scaler <- c()
for(i in 1:100){
print(i)
trees.p[[i]] <- treedata(trees[[i]], chroms)[[1]]
scaler[i] <- max(branching.times(trees.p[[i]]))
trees.p[[i]]$edge.length <- trees.p[[i]]$edge.length/scaler[i]
}
# here we match up our tip data and our
trees <- trees.p
class(trees) <- "multiPhylo"
x <- row.names(treedata(trees[[1]], chroms)[[2]])
chroms <- chroms[chroms$name%in%x,]
rm(trees.p,i,x)
range(chroms$chrom.num)
# we will work in parallele to speed things up
results <- vector(length=100, mode="list")
library(doMC)
registerDoMC(6)
iter.full <- 500
# these values come from a sample of a run of 500 generations on each
# of 5 randomly chosen trees
new.W <- c(1.7,2.3,6,4,1,2.2,1.5)
Ntrees <- 100
i <- 1
# we select wingstate with prob equal to records
wingstate <- c()
for(j in 1:length(chroms$wings.present)){
p <- chroms$wings.present[j]
wingstate[j] <- sample(c(0,1), prob=c(1-p, p), size = 1)
}
# now we set up our chrom matrix
current.chroms <- chroms
current.chroms$wings.present <- wingstate
chrom.mat <- datatoMatrix(current.chroms, range=c(6,32), hyper=T)
# here we just create our likelihood function
lk.mk <- make.mkn(trees[[i]], states=chrom.mat,
k=54, strict=F,
control=list(method="ode"))
# this version creates a one way model where wings can not be regained
con.lk.mk<-constrainMkn(data=chrom.mat,
lik=lk.mk,
hyper=T,
polyploidy=F,
verbose=F,
oneway=T,
constrain=list(drop.demi=T))
# we use a broad prior
prior <- make.prior.exponential(1)
print(paste("Working on dataset", i))
# we use a broad prior
prior <- make.prior.exponential(1)
print(paste("Working on dataset", i))
results[[i]] <- diversitree::mcmc(con.lk.mk,
x.init = runif(8, min = 0, max = 1),
prior = prior, upper = 40, w = new.W,
print.every=10, nsteps = iter.full)
# this version creates a one way model where wings can not be regained
con.lk.mk<-constrainMkn(data=chrom.mat,
lik=lk.mk,
hyper=T,
polyploidy=F,
verbose=F,
oneway=T,
constrain=list(drop.demi=T))
pars(con.lk.mk)
args(con.lk.mk)
argnames(con.lk.mk())
argnames(con.lk.mk
)
# these values come from a sample of a run of 500 generations on each
# of 5 randomly chosen trees
new.W <- c(1.7,2.3,6,4,1,2.2,1.5)
Ntrees <- 100
# we select wingstate with prob equal to records
wingstate <- c()
for(j in 1:length(chroms$wings.present)){
p <- chroms$wings.present[j]
wingstate[j] <- sample(c(0,1), prob=c(1-p, p), size = 1)
}
# now we set up our chrom matrix
current.chroms <- chroms
current.chroms$wings.present <- wingstate
chrom.mat <- datatoMatrix(current.chroms, range=c(6,32), hyper=T)
# here we just create our likelihood function
lk.mk <- make.mkn(trees[[i]], states=chrom.mat,
k=54, strict=F,
control=list(method="ode"))
# this version creates a one way model where wings can not be regained
con.lk.mk<-constrainMkn(data=chrom.mat,
lik=lk.mk,
hyper=T,
polyploidy=F,
verbose=F,
oneway=T,
constrain=list(drop.demi=T))
# we use a broad prior
prior <- make.prior.exponential(1)
print(paste("Working on dataset", i))
results[[i]] <- diversitree::mcmc(con.lk.mk,
x.init = runif(8, min = 0, max = 1),
prior = prior, upper = 40, w = new.W,
print.every=10, nsteps = iter.full)
results[[i]] <- diversitree::mcmc(con.lk.mk,
x.init = runif(7, min = 0, max = 1),
prior = prior, upper = 40, w = new.W,
print.every=10, nsteps = iter.full)
i <- 2
results[[i]] <- diversitree::mcmc(con.lk.mk,
x.init = runif(7, min = 0, max = 1),
prior = prior, upper = 40, w = new.W,
print.every=10, nsteps = iter.full)
# we select wingstate with prob equal to records
wingstate <- c()
for(j in 1:length(chroms$wings.present)){
p <- chroms$wings.present[j]
wingstate[j] <- sample(c(0,1), prob=c(1-p, p), size = 1)
}
# now we set up our chrom matrix
current.chroms <- chroms
current.chroms$wings.present <- wingstate
chrom.mat <- datatoMatrix(current.chroms, range=c(6,32), hyper=T)
# here we just create our likelihood function
lk.mk <- make.mkn(trees[[i]], states=chrom.mat,
k=54, strict=F,
control=list(method="ode"))
# this version creates a one way model where wings can not be regained
con.lk.mk<-constrainMkn(data=chrom.mat,
lik=lk.mk,
hyper=T,
polyploidy=F,
verbose=F,
oneway=T,
constrain=list(drop.demi=T))
# we use a broad prior
prior <- make.prior.exponential(1)
print(paste("Working on dataset", i))
results[[i+1]] <- diversitree::mcmc(con.lk.mk,
x.init = runif(7, min = 0, max = 1),
prior = prior, upper = 40, w = new.W,
print.every=10, nsteps = iter.full)
results <- vector(length=100, mode="list")
library(doMC)
registerDoMC(6)
iter.full <- 500
# these values come from a sample of a run of 500 generations on each
# of 5 randomly chosen trees
new.W <- c(1.7,2.3,6,4,1,2.2,1.5)
Ntrees <- 100
x <- foreach (i = 1:Ntrees) %dopar% {
# we select wingstate with prob equal to records
wingstate <- c()
for(j in 1:length(chroms$wings.present)){
p <- chroms$wings.present[j]
wingstate[j] <- sample(c(0,1), prob=c(1-p, p), size = 1)
}
# now we set up our chrom matrix
current.chroms <- chroms
current.chroms$wings.present <- wingstate
chrom.mat <- datatoMatrix(current.chroms, range=c(6,32), hyper=T)
# here we just create our likelihood function
lk.mk <- make.mkn(trees[[i]], states=chrom.mat,
k=54, strict=F,
control=list(method="ode"))
# this version creates a one way model where wings can not be regained
con.lk.mk<-constrainMkn(data=chrom.mat,
lik=lk.mk,
hyper=T,
polyploidy=F,
verbose=F,
oneway=T,
constrain=list(drop.demi=T))
# we use a broad prior
prior <- make.prior.exponential(1)
print(paste("Working on dataset", i))
results[[i+1]] <- diversitree::mcmc(con.lk.mk,
x.init = runif(7, min = 0, max = 1),
prior = prior, upper = 40, w = new.W,
print.every=10, nsteps = iter.full)
}
# here we discard the first 100 generations as burnin
# we also convert this to rates in millions of years
post.sample <- x[[1]][sample(100:500, 100), 2:8]/scaler[1]
for(i in 2:Ntrees){
post.sample <- rbind(post.sample,
x[[i]][sample(100:500, 100), 2:8]/scaler[i])
}
boxplot(post.sample)
t.test(post.sample$asc1,post.sample$asc2)
View(chrom.mat)
wingstate
help("constrainMkn")
plot(trees[[1]])
plot(trees[[1]],show.tip.label = )
plot(trees[[1]],show.tip.label = F)
View(chroms)
foo <- chroms[,2]
foo <- as.data.frame(chroms[,2]_
foo <- as.data.frame(chroms[,2])
View(foo)
row.names(foo) <- row.names(chroms)
colnames(foo)<-"chrom"
View(foo)
trait.plot(trees[[1]],dat=foo)
library(phytools)
foo <- make.simmap(trees[[1]], foo)
help(make.simmap)
test <- contMap(trees[[1]],foo)
chroms.test <- foo[,1]
names(chroms.test) <- row.names(foo)
help(contMap)
testing <- contMap(trees[[1]], chroms.test)
plot(testing, fsize=.5)
View(current.chroms)
View(current.chroms)
help("datatoMatrix")
View(chrom.mat)
library(evobiR)
# we select wingstate with prob equal to records
wingstate <- StochRound(chroms$wings.absent[j])
# now we set up our chrom matrix
current.chroms <- cbind(chroms$name, chroms$chrom.num, wingstate)
View(current.chroms)
# we select wingstate with prob equal to records
wingstate <- StochRound(chroms$wings.absent)
# now we set up our chrom matrix
current.chroms <- cbind(chroms$name, chroms$chrom.num, wingstate)
View(current.chroms)
StochRound(chroms$wings.absent)
library(evobiR)
library(chromePlus)
library(coda)
library(diversitree)
library(evobiR)
trees <- read.nexus("../data/trees.nexus")
chroms <- read.csv("../data/hap.auto.csv", as.is=T)
View(chroms)
# state 1 is winged
#lets prune trees
library(geiger)
row.names(chroms) <- chroms$name
# here we scale our trees to unit length and store there orginal depth
trees.p <- list()
scaler <- c()
for(i in 1:100){
print(i)
trees.p[[i]] <- treedata(trees[[i]], chroms)[[1]]
scaler[i] <- max(branching.times(trees.p[[i]]))
trees.p[[i]]$edge.length <- trees.p[[i]]$edge.length/scaler[i]
}
# here we match up our tip data and our
trees <- trees.p
class(trees) <- "multiPhylo"
x <- row.names(treedata(trees[[1]], chroms)[[2]])
chroms <- chroms[chroms$name%in%x,]
rm(trees.p,i,x)
range(chroms$chrom.num)
# these values come from a sample of a run of 500 generations on each
# of 5 randomly chosen trees
new.W <- c(1.7,2.3,6,4,1,2.2,1.5)
Ntrees <- 100
# we select wingstate with prob equal to records
wingstate <- StochRound(chroms$wings.present)
# now we set up our chrom matrix
current.chroms <- cbind(chroms$name, chroms$chrom.num, wingstate)
View(current.chroms)
chrom.mat <- datatoMatrix(current.chroms, range=c(6,32), hyper=T)
View(current.chroms)
help(datatoMatrix)
View(current.chroms)
datatoMatrix(current.chroms, range=c(6,32), hyper=T)
# now we set up our chrom matrix
current.chroms <- data.frame(chroms$name, chroms$chrom.num, wingstate)
chrom.mat <- datatoMatrix(current.chroms, range=c(6,32), hyper=T)
View(chrom.mat)
# here we just create our likelihood function
lk.mk <- make.mkn(trees[[i]], states=chrom.mat,
k=54, strict=F,
control=list(method="ode"))
i <- 1
# here we just create our likelihood function
lk.mk <- make.mkn(trees[[i]], states=chrom.mat,
k=54, strict=F,
control=list(method="ode"))
# this version creates a one way model where wings can not be regained
con.lk.mk<-constrainMkn(data=chrom.mat,
lik=lk.mk,
hyper=T,
polyploidy=F,
verbose=F,
oneway=T,
constrain=list(drop.demi=T, drop.poly=F))
# we use a broad prior
prior <- make.prior.exponential(1)
print(paste("Working on dataset", i))
results[[i]] <- diversitree::mcmc(con.lk.mk,
x.init = runif(7, min = 0, max = 1),
prior = prior, upper = 40, w = new.W,
print.every=10, nsteps = iter.full)
iter.full <- 500
# these values come from a sample of a run of 500 generations on each
# of 5 randomly chosen trees
new.W <- c(1.7,2.3,6,4,1,2.2,1.5)
Ntrees <- 100
results[[i]] <- diversitree::mcmc(con.lk.mk,
x.init = runif(7, min = 0, max = 1),
prior = prior, upper = 40, w = new.W,
print.every=10, nsteps = iter.full)
con.lk.mk.no.poly<-constrainMkn(data=chrom.mat,
lik=lk.mk,
hyper=T,
polyploidy=F,
verbose=F,
oneway=T,
constrain=list(drop.demi=T, drop.poly=F))
fit.with.poly <- find.mle(con.lk.mk,
x.init = runif(7, min = 0, max = 1),
upper = 40, w = new.W, )
fit.with.poly <- find.mle(con.lk.mk,
x.init = runif(7, min = 0, max = 1),
upper = 40)
fit.with.nopoly <- find.mle(con.lk.mk,
x.init = runif(7, min = 0, max = 1),
upper = 40)
anova(fit.with.nopoly, fit.with.poly)
anova(fit.with.poly, fit.with.nopoly)
fit.with.poly
fit.with.poly$lnLik
fit.with.nopoly$lnLik
fit.with.nopoly <- find.mle(con.lk.mk.no.poly,
x.init = runif(7, min = 0, max = 1),
upper = 40)
con.lk.mk.no.poly<-constrainMkn(data=chrom.mat,
lik=lk.mk,
hyper=T,
polyploidy=F,
verbose=F,
oneway=T,
constrain=list(drop.demi=T, drop.poly=T))
fit.with.nopoly <- find.mle(con.lk.mk.no.poly,
x.init = runif(7, min = 0, max = 1),
upper = 40)
fit.with.nopoly <- find.mle(con.lk.mk.no.poly,
x.init = runif(5, min = 0, max = 1),
upper = 40)
fit.with.poly$lnLik
fit.with.nopoly$lnLik
anova(fit.with.poly, fit.with.nopoly)
fit.with.nopoly$par
# we select wingstate with prob equal to records
wingstate <- StochRound(chroms$wings.present)
# now we set up our chrom matrix
current.chroms <- data.frame(chroms$name, chroms$chrom.num, wingstate)
chrom.mat <- datatoMatrix(current.chroms, range=c(6,32), hyper=T)
# here we just create our likelihood function
lk.mk <- make.mkn(trees[[i]], states=chrom.mat,
k=54, strict=F,
control=list(method="ode"))
# this version creates a one way model where wings can not be regained
con.lk.mk<-constrainMkn(data=chrom.mat,
lik=lk.mk,
hyper=T,
polyploidy=F,
verbose=F,
oneway=T,
constrain=list(drop.demi=T, drop.poly=F))
# we use a broad prior
prior <- make.prior.exponential(.5)
print(paste("Working on dataset", i))
# we will work in parallele to speed things up
results <- vector(length=100, mode="list")
# we use a broad prior
prior <- make.prior.exponential(.5)
print(paste("Working on dataset", i))
results[[i]] <- diversitree::mcmc(con.lk.mk,
x.init = runif(7, min = 0, max = 1),
prior = prior, upper = 40, w = new.W,
print.every=10, nsteps = iter.full)
# we use a broad prior
prior <- make.prior.exponential(2)
print(paste("Working on dataset", i))
results[[i]] <- diversitree::mcmc(con.lk.mk,
x.init = runif(7, min = 0, max = 1),
prior = prior, upper = 40, w = new.W,
print.every=10, nsteps = iter.full)
help(make.simma)
help(make.simmap)
.5-.399
.637-.5
.5-.317
.658-.5
